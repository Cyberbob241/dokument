\chapter{Methoden und Verfahren zur Detektion virtueller Umgebungen}\label{cha:Virtualisierung}

	%Strukturierungsvorschlag:
	
	%?Looking for VME artifacts in processes, file system, and/or registry
	%?Looking for VME artifacts in memory
	%?Looking for VME-specific virtual hardware
	%?Looking for VME-specific processor instructions and capabilities
	
	Zur Vermeidung der Extraktion von internen Verhaltensparametern einer konkreten Malware-Instanz verfügen moderne Schadsoftware-Implementierungen zunehmend über Funktionalität, welche die Identifikation potentieller Analyseumgebungen ermöglicht. Initial wurden hierbei vergleichsweise generische Verschleierungsmechanismen realisiert, deren Primärintention die Obstruktion der Durchführung von statischen Analyseansätzen darstellt. Exemplarisch seien an dieser Stelle die weiterhin aktiv verwendeten Methoden der asymmetrischen Verschlüsselung und Code-Obfuscation referenziert, welche speziell im Kontext von manuellen  Analyseverfahren hohe Latenzen induzieren können.\\
	\noindent Als Reaktion auf die Einführung signaturbasierter Detektionsmechanismen durch IT-Sicherheitsdienstleister wurden Malware-Implementierungen zunehmend um eine dynamische Komponente zur Verschleierung der inhärenten Codestrukturen erweitert. Hierbei induzieren automatisierte Modifikationen des Quellcodes signifikante Diskrepanzen innerhalb der generierten Signaturdaten, was final in der erfolgreichen Evasion kongruenz- und korrelationsbasierter Detektionsmethoden resultiert. 
	Die in der Literatur durch den Terminus \textit{Polymorphismus} bezeichnete Funktionalität kann dabei beispielsweise unter Verwendung von Transformationsoperationen mit aleatorisch generierten Initialisierungsvektoren realisiert werden, welche unter Beibehaltung der semantischen Kongruenz die Struktur ausgewählter Quellcode-Anteile stochastisch signifikant modifizieren. \\
	\noindent Moderne Malware-Implementierungen erweitern die generischen Evasionstechniken um Funktionalität, welche die Detektion der Präsenz von virtualisierten Analysesystemen realisiert. Der Sicherheitsdienstleister \textit{McAfee} beziffert den in Abbildung \ref{fig:evasion} visualisierten Anteil solcher Methoden an globalen \mbox{Evasionstechniken im Jahr 2017 auf etwa 23,3\% \cite{mcafee0617}.}
	
		\begin{figure}[h] 
			\centering
			\includegraphics[width=0.7\textwidth]{Bilder/stats/evasion.png}
			\caption[Anteil der Virtualisierungsdetektion an Evasionstechniken]{Anteil der Virtualisierungsdetektion an Evasionstechniken (nach \cite{mcafee0617})}
			\label{fig:evasion}
		\end{figure}
	
	%QUELLE: https://www.mcafee.com/us/resources/reports/rp-quarterly-threats-jun-2017.pdf
	
	\noindent Als Resultat der im vorherigen Abschnitt \ref{sec:virtual} präsentierten Entwicklungsparameter wird die Implementierung von Maßnahmen zur Virtualisierungs-Detektion im Malware-Kontext zunehmend intensiviert. Äquivalente Tendenzen lassen sich aus einer vom IT-Software- unternehmen Symantec publizierten Studie des Sicherheitsanalysten Candid Wueest \mbox{deduzieren}, welche eine kontinuierliche Inkrementierung des Anteils von Malware mit nativ integrierter Detektionsfunktionalität identifiziert \mbox{(vergleiche Abbildung \ref{fig:anteil} unten) \cite{symantecescape}}.\\
	%https://www.symantec.com/connect/sites/default/files/users/user-2935611/Detect_Virtual_Machines_2.png
	
	\begin{figure}[h] 
		\centering
		\includegraphics[width=0.76\textwidth]{Bilder/stats/anteilvirtdetect.png}
		\caption[Entwicklung des Malware-Anteils mit Virtualisierungs-Detektion]{Entwicklung des Malware-Anteils mit Virtualisierungs-Detektion \cite{symantecescape}}
		\label{fig:anteil}
	\end{figure}	
	
	\noindent Die auf Basis der Messwerte interpolierte Regressionsgerade visualisiert die grundlegend steigende Tendenz der Entwicklung. Die quantitative Limitierung des relativen Anteils auf ein Maximum von etwa 34\% kann unter anderem mit der verbreiteten Instrumentalisierung sogenannter \textit{packer-} und \textit{crypter-}Komponenten begründet werden, welche in zahlreichen Malware-Derivaten als koordinierendes Element fungieren und eine generische Implementierung von Detektionsfunktionalität offerieren. \textit{Packer}, in der Literatur auch als \textit{runtime packers} oder \textit{self-extracting archives} bezeichnet, repräsentieren Archive mit integrierter Funktionalität zur Laufzeit-Extraktion von internen Payload-Komponenten. Auf diese Weise können die eigentlichen Malware-Binaries vor automatisierten Analyseprozessen innerhalb der Dateisystem-Umgebungen verborgen und die Dateiumfänge effektiv minimiert werden. 
	Die sogenannten \textit{crypter}-Module offerieren weitestgehend analoge Funktionalität, wobei die dynamische Extraktion zur Verschleierung der Malware-Präsenz um zusätzliche Verschlüsselungs- und Obfuscation-Mechanismen erweitert werden \cite{packer}.\\
	% Quelle: https://blog.malwarebytes.com/cybercrime/malware/2017/03/explained-packer-crypter-and-protector/
	\noindent Ausgehend von der individuellen Zielperspektive konkreter Malware-Implementierungen verzichten einige Derivate jedoch auch bewusst auf die Implementierung dedizierter Detektionstechniken. Dieses Vorgehen kann sich beispielsweise als sinnvoll erweisen, wenn die Angriffsziele selbst potentiell in virtualisierten Systemumgebungen realisiert sind. Auf Basis der in Abschnitt \ref{sec:virtual} präsentierten Referenzen, welche die wirtschaftliche Attraktivität der Virtualisierungs-Technologie sowie statistische Erhebungen zu deren Verbreitung illustrieren, kann seit dem Jahr 2011 die Majorität der global erreichbaren Serversysteme als virtualisiert konstatiert werden. Die erfolgreiche Kompromittierung eines Zielsystems ist dabei im Regelfall direkt von der konkreten Realisierung der Malware-inhärenten Funktionalität abhängig. Insbesondere im Kontext virtueller Systemumgebungen kann die Verwendung spezieller Methoden und Verfahren für die erfolgreiche Ausführung der konzipierten Schadfunktionalität erforderlich sein, weshalb in vielen Fällen eine exakte Differenzierung zwischen virtuellen und physischen Hostsystemen obligatorisch ist.\\
	\noindent Basierend auf den im vorherigen Abschnitt präsentierten Erkenntnissen werden im Rahmen dieses Kapitels wesentliche Konzepte zur Implementierung der Detektionsfunktionalität präsentiert und die Realisierbarkeit im Kontext verdeckter Malware-Installationen evaluiert. Initial wird hierzu ein hierarchisches Kategorisierungsmodell konzipiert, welches die Einordnung der identifizierten Maßnahmen und Techniken in einen globalen System- \makebox[\linewidth][s]{kontext und damit final die Vergleichbarkeit der analysierten Methodiken ermöglicht.}

	\section{Konzeptionelle Aspekte der Kategorisierung}\label{sec:konzept}
	
		Aus stark abstrahierender Perspektive können die elementaren Bestandteile produktiver Computersysteme in vier zentrale Kategorien differenziert werden:
		als koordinierende Instanz agiert der \textit{Prozessor} (auch als \textit{Central Processing Unit}, kurz CPU, bezeichnet), welcher die Ausführung von in einer \textit{Hauptspeicherkomponente} hinterlegten Programmen realisiert. In Ergänzung zur initialen Hardwarekonfiguration werden unter Verwendung dieser Elemente auch externe \textit{Peripherie-Geräte} gesteuert, welche global standardisierte Protokolle zur Realisierung der Kommunikation mit CPU und Hauptspeicher verwenden. Die primäre Interaktionsschnittstelle zwischen menschlichem Benutzer und den Hardwarekomponenten wird dabei durch das softwarebasierte \textit{Betriebssystem} repräsentiert, welches die Verwaltung aggregierter Daten in Form eines hierarchischen Dateisystems erlaubt. Um den regulären Systembetrieb eines physischen Host-Systems erfolgreich virtualisieren zu können, muss das koordinierende Hypervisor-Element auf jeder dieser Abstraktionsebenen die korrespondierende Emulationsfunktionalität realisieren.\\
		Die hier gewählte Form einer simplifizierten Betrachtung ermöglicht die Segmentierung von elementaren Systemkomponenten in weitestgehend disjunkte Kategorien, deren Komposition wiederum eine Partition bildet. Auf diese Weise kann eine generische Taxonomie generiert werden, welche eine solide Basis für die Kategorisierung der im weiteren Verlauf analysierten Methodiken darstellt. Zur Illustration der zunehmenden Komplexität, mit welcher Detektionsmechanismen sowie potentielle Evasionsansätze in produktiven Systemumgebungen konfrontiert werden, repräsentiert die klimatische Komposition der folgenden Abschnitte die zunehmende Abstraktion der erforderlichen Analyseansätze. Die im Rahmen der Detektion instrumentalisierten Systemparameter reichen dabei von reiner Präsenzdetektion verräterischer Dateien bis hin zur detaillierten Analyse von Resultaten komplexer CPU-Instruktionen.
		Als Referenzsysteme fungieren innerhalb der folgenden Evaluationsabschnitte jeweils auf die initiale Konfiguration reduzierte Installationen von Ubuntu 16.04.2 LTS sowie Windows 10 Pro (Build 16299), welche aufgrund der limitierten Hardware- und Lizenz-Verfügbarkeit primär unter Verwendung der Virtualisierungs-Realisierungen \textit{Oracle VirtualBox} (Version 5.1.26) und \textit{VMware Workstation Pro} (Version 14.1.1) analysiert wurden (vergleiche  Anhang \ref{anhang} für eine detaillierte Auflistung der Konfigurationsparameter). Zur realitätsnahen Nachbildung einer produktiven Systemumgebung verfügen die entsprechenden Betriebssystem-Installationen zusätzlich über die aktuellste Version der jeweiligen Gasterweiterungen, welche Mechanismen zur Optimierung der Interoperabilität zwischen Host- und Guest-System offerieren. Die unter Verwendung dieser Systemkonfigurationen generierten Resultate erheben dabei keinen exhaustiven Anspruch, sondern werden lediglich zu Illustrationszwecken  eingesetzt.
 	
	\section{VM-Artefakte in Dateisystemen, Prozessen und Registry}\label{sec:filesystem}
	
		Das Dateisystem repräsentiert eines der fundamentalen Konzepte zur Organisation von Daten auf einer physischen Speicherkomponente. Hierzu werden Informationsfragmente zu Dateien aggregiert, welche den gesamten Datenbestand in funktionaler Abstraktion von der bitweisen Informationssicherung auf dem Datenträger in isolierte Entitäten separieren. Die hierarchische Strukturierbarkeit sowie die Möglichkeit zur Korrelation und Attributierung von Daten erleichtert dem Systembenutzer dabei sowohl die Administration als auch die Interaktion mit großen Datenbeständen signifikant.
		
		\noindent In Unix-basierten Systemumgebungen gestaltet sich die Realisierung generischer Detektionsmechanismen aufgrund des architektonischen \textit{Everything-is-a-file}-Konzeptes (deutsch: \textit{Alles-ist-eine-Datei}-Konzept), welches unter Verwendung repräsentativer Dateiobjekte eine homogene Interaktionsschnittstelle zu allen systeminhärenten Ressourcen wie Daten und Hardware-Komponenten offeriert, als vergleichsweise einheitlich umsetzbar. Aus diesem Grund kann die Extraktion konkreter Hardwareattribute oder spezifischer Treiberparameter meist schon durch die gezielte Analyse der entsprechenden Dateisystem-Objekte realisiert werden. Um final die klare Distinktion dieses Abschnittes von den darauffolgenden Kapiteln zu garantieren, innerhalb welcher unter anderem eine dedizierten Analyse der Detektionsoptionen im Peripherie-Kontext stattfindet, soll im Rahmen dieses Abschnittes primär die Evaluation von  Systemparametern und Attributen der elementaren Kernkomponenten und Bussysteme priorisiert werden.\\
		Die zur automatisierten Analyse virtualisierter Unix-Systemumgebungen identifizierten Elemente lassen sich konzeptionell in zwei wesentliche Kategorien differenzieren. Die Majorität der im Verlauf dieses Abschnittes untersuchten Ansätze wird im Wesentlichen durch universell verfügbare Instruktionen repräsentiert, welche nativ in zahlreiche Unix-Distributionen integriert sind. Ergänzend dazu werden im Anschluss aus Gründen der Vollständigkeit ausgewählte Implementierungen thematisch relevanter Drittsoftware präsentiert, welche innerhalb der regulären Standard-Paketquellen zur Verfügung stehen.
		
		\noindent Die durch manuelle Editierung von Systemparametern induzierte Komplexität nimmt bei virtualisierten Systemen proportional zur Abstraktion von konkreten Hardwareparametern ab, weshalb insbesondere hardwarenahe Attribute als belastbare Informationsquelle interpretiert werden. Aus diesem Grund wird im Rahmen des folgenden Abschnittes die Analyse potentieller Virtualisierungs-Indikatoren auf Ebene der absoluten Grundlage abstrakter Software-Funktionalität initiiert, welche durch das \textit{Basic Input/Output System} (BIOS) repräsentiert wird. Das BIOS, dessen modernisiertes Äquivalent als \textit{Unified Extensible Firmware Interface} (UEFI) bezeichnet wird, implementiert auf einer dedizierten Speicherkomponente des Systems die zur Betriebsinitiierung und -konfiguration erforderliche Funktionalität unter Verwendung rudimentärer Prozessorinstruktionen. Im Rahmen dieses Prozesses realisieren die BIOS-Implementierungen unter anderem eine \mbox{hardwarenahe} Kompatibilitätsprüfung von identifizierten Komponenten. Auch die im Kontext virtualisierter Systemumgebungen eingesetzten BIOS-Simulationen evaluieren wesentliche Parameter der (in diesem Fall emulierten) Hardware-Komponenten, wobei aufgrund der unmittelbaren Hardwarenähe intentionale Manipulationen von  potentiellen Virtualisierungs-Indikatoren praktisch kaum realisierbar sind. \\
		Die detaillierten Protokolle des Bootprozesses werden bei der Majorität verbreiteter Unix-Distributionen innerhalb des dedizierten Systemverzeichnisses /var/log/messages.* zentral archiviert. Unter Verwendung einer quantitativ limitierten Buffer-Instanz offerieren die Systeme mit der \textit{dmesg}-Instruktion dabei eine dynamische Interaktionsschnittstelle, welche die Kernel-Meldungen des Bootprozesses in der Standardausgabe visualisiert. Insbesondere in zeitlicher Nähe des Systemboots können hieraus mittels diverser Parsing-Mechanismen konkrete Initialisierungsinformationen über die virtualisierte BIOS-Instanz und korrespondierende Gerätetreiber extrahiert werden. Im Kontext automatisierter Detektionsimplementierungen kann exemplarisch die folgende Instruktion genutzt werden, welche den \textit{grep}-Befehl zur Substring-basierten Filterung der umfangreichen Bufferinhalte auf die im Bereich der \mbox{Virtualisierungsdetektion relevanten Aspekte instrumentalisiert:}
		\begin{center}
			dmesg | grep -i <virtual|vbox|vmware|...>
		\end{center}
		\noindent Die hierbei generierten Ausgabefragmente können final auf die Präsenz verschiedener Indikatorelemente untersucht werden, welche neben der eigentlichen Detektion virtualisierter Systemumgebungen meist zusätzlich die Extraktion exakter Versionsparameter der Hypervisor-Lösung ermöglichen. In das verwendete Buffer-Elemente werden bei regulärer Systemaktivität jedoch kontinuierlich weitere Systembenachrichtigungen integriert, was final in der Verdrängung der initialen Bootinformationen und damit der Notwendigkeit zur manuellen Analyse der referenzierten Log-Dateien resultiert \cite{detectlinuxvm}. 
		%Quelle: http://www.dmo.ca/blog/detecting-virtualization-on-linux/ 
		Aus diesem Grund offeriert das Betriebssystem durch die \textit{dmidecode}-Instruktion eine alternative Schnittstelle mit persistenter Datenbereitstellung, welche die interaktive Extraktion von BIOS-Attributen und Parametern der Peripherie-Konfigurationen realisiert. Die klassische Verwendung sieht hierbei die gezielte Abfrage dedizierter Attributwerte vor; für die detaillierte Dokumentation valider Identifikatoren sowie korrespondierer Kombinationsmöglichkeiten sei an dieser Stelle auf \cite{dmidecode} verwiesen. %Quelle: https://wiki.ubuntuusers.de/dmidecode/
		Die Detektion virtueller Systeme kann dabei jedoch bereits unter Verwendung der im \mbox{Folgenden dargestellten Parametrisierung realisiert werden:}
		\begin{center}
			dmidecode -s system-product-name
		\end{center}
		Innerhalb physischer Systemumgebungen resultiert diese Abfrage in der Emission des konkreten Modellnamens (beispielsweise: 'MacBookPro6.2'), während virtuelle Systeme meist Informationen über die verwendete Hypervisor-Realisierung zur Verfügung stellen (exemplarische Ausgaben: 'VMware Virtual Platform', 'VirtualBox'). Innerhalb modifizierter Systemkonfigurationen mit defizitärem Ausgabeverhalten (ältere Hypervisor-Implementierungen substituieren Teile der Attributwerte beispielsweise durch generische Bezeichner) kann die exhaustive Ausgabe der \textit{dmidecode}-Instruktion auch manuell auf relevante Artefakte sondiert werden. In diesem Kontext kann beispielsweise auch die Verwendung des \textit{egrep}-Derivats der \textit{grep}-Instruktion sinnvoll sein, um die Spezifikation von Anteilen der gesuchten Textfragmente in Form regulärer Ausdrücke zu ermöglichen:
		\begin{center}
			dmidecode | egrep -i '<manufacturer|product|virtual|...>'
		\end{center}
	
		%- dmesg | grep -i virtual
		%  (dmesg visualisiert Kernel-Messages, insbesondere nach Boot Initialisierungsinformationen über virtualisierte BIOS-Instanz und Gerätetreiber extrahierbar. Konkreter grep-Parameter kann zwischen verschiedenen Virtualisierungs-Realisierungen divergieren; falls boot länger her check /var/log/dmesg;
		%  Funktioniert verlässlich unter VMWare, VBox, Qemu, VirtualPC, Xen)
		  % QUelle: http://www.dmo.ca/blog/detecting-virtualization-on-linux/ 
		%- dmidecode -s system-product-name / dmidecode | egrep -i '<manufacturer|product|virtual|...>' 
		%  (Realisiert interaktive Extraktion von BIOS-Informationen, auch über /dev/mem; auch Informationen über Peripherie, andere Parameter prüfen
		
		\noindent Aufgrund der Universalität der hierbei verwendeten Mechanismen, welche primär auf der Interpretation generisch extrahierter BIOS-Parameter basiert, generieren die hier präsentieren Ansätze unter allen bekannten Virtualisierungslösungen stabile Resultate. Die korrekte Funktionalität konnte dabei unter anderem für Implementierungen wie VMware, VirtualBox, Qemu, VirtualPC und Xen experimentell verifiziert werden \cite{detectlinuxvm}. Alternativ können die gesammelten Informationen auch durch manuelle Examination der korrespondierenden Dateielemente akquiriert werden, welche sich primär innerhalb der Systemverzeichnisse /sys/firmware sowie /proc befinden. In Ergänzung dazu ermöglicht auch die Analyse des physischen Hauptspeicherabbilds, dessen entsprechendes Referenzobjekt unter /dev/mem abgelegt ist, die Extraktion der betrachteten Parameterwerte.\\
		%Quelle: http://www.dmo.ca/blog/detecting-virtualization-on-linux/ (wie oben)
 		\noindent Wie bereits zu Beginn dieses Abschnittes erläutert, können insbesondere aus hardwarespezifischen Attributen von identifizierten Peripherie-Komponenten belastbare Erkenntnisse über den Virtualisierungsgrad eines analysierten Host-Systems deduziert werden. Ein mächtiges Instrument zur Durchführung solch dedizierter Analyseansätze wird durch die Standard-Instruktion \textit{lshw} (\textit{list hardware}) repräsentiert, welche eine Übersicht zentraler Konfigurationsparameter von erkannten Hardwarekomponenten (sowohl intern als auch peripher) offeriert. Der Befehl kann dabei unter Verwendung der Parametrisierung 
 		\begin{center}
 			lshw -class system 
 		\end{center}
 		auf elementare Systemparameter reduziert werden, wobei insbesondere die Attribute \textit{product} und \textit{vendor} (Anbieter) als Indikator für die Präsenz virtueller Systemumgebungen fungieren. Bei der Durchführung dieser Instruktion wird auf Basis der aktuellen Systemkonfiguration die Betriebsgrundlage des Computers identifiziert, welche im Gegensatz zur Mainboard-Instanz eines physischen Hosts durch das entsprechende Hypervisor-Element repräsentiert wird. Die exemplarische Ausgabe innerhalb einer VMware-Umgebung ist im untenstehendem Listing \ref{list:lshw} visualisiert, wobei ausgewählte Anteile der zur Identifikation von relevanten Systemparametern \mbox{erforderlichen Attribute explizit hervorgehoben sind.} 
 
\begin{lstlisting}[title=Auszug der Instruktion \textit{lshw -class system}, firstnumber=1, , language=sh, label=list:lshw, caption=Auszug der Instruktion \textit{lshw -class system}]
	root@ubuntudesktop:~# lshw -class system
	ubuntudesktop
		description: Computer
		product:     VMware Virtual Platform
		vendor:      VMware, Inc.
		version:     None
		serial:      VMware-56-4D-EF-D0-7F-48-23-3E
		width:       64 bits
		[...]
\end{lstlisting}
\nopagebreak
		\noindent Äquivalente Resultate ergeben sich bei der Verwendung von alternativen Hypervisor-Implementierungen; so wird beispielsweise in einer untersuchten VirtualBox-Umgebung der Attributwert \textit{product} als \textit{VirtualBox} identifiziert, während mit \textit{innotek GmBH} \mbox{eines} der an Implementierung und Entwicklung der VirtualBox-Hypervisor beteiligten Subunternehmen als \textit{vendor} erkannt wird. Des Weiteren steht in diesem Systemkontext mit \textit{family(=Virtual Machine)} standardmäßig ein weiterer Parameter zur Verfügung, welcher als zusätzlicher Indikator für die Präsenz eines virtuellen Systems fungieren kann.
 	
 		%- lshw -class system 
		%(list hardware, visualisiert Parameter erkannten Hardwarekomponenten (intern und peripher) hier reduziert auf zentrale Systeminformationen; insbesondere 'family=Virtual Machine' bei allen Virtualisierungs- und Hypervisor-Implementierungen standardmäßig präsent)
		
		\noindent Abstrahiert von der Extraktion repräsentativer BIOS-Parameter kann in Unix-Systemen auch der Betriebssystem-Kernel zur Informationsgewinnung genutzt werden. Der ursprünglich monolithisch konzipierte Linux-Kernel implementiert hierbei Funktionalität zur adaptiven Integration von Zusatzmodulen, welche insbesondere zur dynamischen Einbindung der stark systemspezifischen Hardware-Treiber eingesetzt werden \cite{finkenjay}. 
		%Quelle: http://systhread.net/texts/200510kdiff.php
		Unter Verwendung einer dieser beiden semantisch äquivalenten Standard-Instruktionen 
		\begin{center}
			lsmod / kmod list
		\end{center}
		kann eine Übersicht aktuell aktivierter Kernelmodule generiert werden, wodurch häufig die Namensattribute interner Hardware-Treiber exponiert werden. Analog zu den im BIOS-Kontext präsentierten Analyseansätzen ermöglicht auch hier die Substring-basierte Filterung der Ausgabe die Detektion von virtualisierten Treiberinstanzen.
		%- lsmod 
		%(Zeigt aktivierte Kernelmodule an, hierbei häufig interne Hardware-Treiber sichtbar) 
		\noindent Ein ähnlicher Analyseansatz wird durch die Instrumentalisierung systeminhärenter Namensattribute realisiert, deren Administration unter parametrisierter Verwendung der Instruktion 
		\begin{center}
			hostnamectl
		\end{center}
		\noindent ermöglicht wird. Die Ausgabe dieses Verwaltungswerkzeugs umfasst mitunter einen dedizierten \textit{Virtualization}-Parameter, welcher Namensattribute des Herstellers potentiell präsenter Hypervisor-Komponenten extrahiert. Auch das Attribut \textit{Icon Name} kann in diesem Kontext als Indikator für die Differenzierung zwischen physischen (\textit{computer}) und virtuellen Systemen (\textit{/computer-vm}) eingesetzt werden. Die referenzierten Parameter \makebox[\linewidth][s]{sind im Rahmen einer exemplarischen Ausgabe-Darstellung in Listing \ref{list:hctl} visualisiert.}
\begin{lstlisting}[title=Auszug der Instruktion \textit{hostnamectl}, firstnumber=1, , language=sh, label=list:hctl, caption=Auszug der Instruktion \textit{hostnamectl}]
	root@ubuntudesktop:~# hostnamectl
		Static hostname: ubuntudesktop
		Icon name: computer-vm
		Chassis: vm
		Machine ID: b37aaf8a824e4354b9914dd2dc5b58b8
		Boot ID: 05692628bf2646ca8ffc72543467a132
		Virtualization: vmware
		Operating System: Ubuntu 16.04.3 LTS
		Kernel: Linux 4.13.0-26-generic
\end{lstlisting}		
		
		
 		%- hostnamectl
		%	(Ermöglicht Administration von high-level Namensattributen der Systemumgebung. Hierbei dedizierter \textit{Virtualization}-Parameter verfügbar, der Hersteller  %   der Hypervisor-Komponente benennt; weiterhin \textit{Icon Name}, Indikator für Differenzierung zwischen physischen (\textit{computer}oder
		%   \textit{computer-laptop}) und virtuellen Systemen (\textit{/computer-vm} ider \textit{computer-container}))
		%- lsmod 
		%(Zeigt aktivierte Kernelmodule an, hierbei häufig interne Hardware-Treiber sichtbar)  
		\noindent In Ergänzung zu den in diesem Abschnitt präsentierten Instruktionen, welche nativ in die Majorität der Unix-Derivate integriert sind, implementieren auch einige der Softwareinstallationen innerhalb der Standard-Paketquellen relevante Detektionsfunktionalität. 
		So offerieren beispielsweise die auf VMware-Umgebungen optimierten \textit{open-vm-tools} die Instruktion \textit{vmware-checkvm}, welche die aggregierte Analyse verschiedener, interner Dateisystem-Parameter zur Determinierung des Betriebs in einem virtualisiertem Systemkontext realisiert \cite{openvmtools}.
		%Quelle: https://github.com/vmware/open-vm-tools
		Weitestgehend kongruente Funktionalität wird durch das Hypervisor-unabhängige Analysewerkzeug \textit{virt-what} zur Verfügung gestellt, welches sowohl die automatisierte Detektion repräsentativer Dateien als auch die Analyse von Systemdateien auf Signaturen virtualisierter Hardware-Komponenten bereitstellt \cite{virtwhat}. 
		% Quelle: https://people.redhat.com/~rjones/virt-what/
		Für detaillierte Ausführungen zu verfügbaren Parametern oder Aspekten der internen Implementierung sei an dieser Stelle jedoch auf die Dokumentation der Elemente verwiesen. Einige der hier vorgestellten Betriebssystem-Instruktionen erfordern mitunter zusätzlich die Ausführung mit Administrator-Berechtigungen, weshalb sich die konkrete Implementierung dieser Maßnahmen im Malware-Kontext als schwierig erweisen kann.\\
		\noindent Im direkten Vergleich stehen innerhalb des Dateisystems von Windows-Systemumgebungen signifikant weniger Dateien mit potentiell kompromittierenden Namensattributen zur Verfügung, da Windows die Parametrisierung zentraler Systemanwendungen unter Verwendung einer dedizierten Verwaltungs-Komponente (\textit{Registry}) realisiert. Aus diesem Grund instrumentalisieren die wesentlichen Detektionsmethoden primär die \textit{Windows Management Instrumentation} (auch als WMI-Schnittstelle bezeichnet), welche die zentralisierte Administration elementarer Aspekte der Systemkonfiguration erlaubt. Die konsolenbasierte Interaktion mit der WMI-Umgebung wird unter Verwendung der \textit{wmic}-Instruktion realisiert, welche über Angabe von Folgeparametern in thematische Subbereiche differenziert werden kann. Exemplarisch seien an dieser Stelle das generalisierte \textit{computersystem} sowie das spezifischere \textit{bios} referenziert, wobei insbesondere die Subkategorie \textit{computersystem} die feingranulare Extraktion zahlreicher, detaillierter Systemparameter ermöglicht:
		\begin{center}
			wmic computersystem get \textbackslash\\
			manufacturer, model, hypervisorpresent, systemfamily, [...]
		\end{center}
		\noindent 	Die hier präsentierte Parametrisierung kann im Kontext der Virtualisierungs-Detektion dynamisch um weitere Anfrage-Attribute erweitert werden, welche ebenfalls zur Deduktion der verwendeten Hypervisor-Implementierung kontribuieren können. Das Resultat der im obigen Abschnitt exemplarisch konstruierten Instruktion ist aus Gründen der Visualisierung in untenstehendem Code-Listing \ref{list:wmic} in leicht gekürzter Form dargestellt.
		
		\begin{lstlisting}[title=Auszug der Instruktion \textit{wmic}, firstnumber=1, , language=sh, label=list:wmic, caption=Auszug der Instruktion \textit{wmic}]
   C:\#> wmic computersystem get manufacturer, model, \ hypervisorpresent, oemstringarray, systemfamily
   HypervisorPresent  Manufacturer  Model      SystemFamily
   TRUE               VMware,Inc.   VMware 7,1 Virtual Machine
		\end{lstlisting}
		%- wmic computersystem get manufacturer, model, hypervisorpresent, oemstringarray, systemfamily
		%\vspace{\baselineskip}
		
		\noindent Analog zum hier präsentierten Vorgehen lassen sich unter Verwendung der \textit{wmic}-Instruktion auch wesentliche Konfigurationsparameter des BIOS extrahieren. Besondere Relevanz besitzen hierbei die Parameter \textit{serialnumber} und \textit{version}, welche in Form eines kompromittierenden Präfixes häufig Informationen über die verwendete Hypervisor-Implementierung\nopagebreak\\ emittieren (vergleiche hierzu auch den Attributwert des \textit{serial}-Eintrags	 in Listing \ref{list:lshw}).\\
				%- wmic bios get serialnumber, version (0 oder Präfix bei virtuell)
				
		\noindent Alternativ kann eine Übersicht zentraler Systemparameter von Windows-Umgebungen auch durch den \textit{systeminfo}-Befehl akkumuliert akquiriert werden.	Neben einer nativ integrierten Hypervisor-Erkennung verfügt diese Instruktion zusätzlich über Informationen zu den Attributen Systemhersteller, Systemmodell und  BIOS-Version, deren kombinierte Interpretation analog zu den vorhergehenden Ausführungen zur Determinierung des Virtualisierungs-Status genutzt werden kann. Die Extraktion der Werte erfordert jedoch die Implementierung von individuell angepassten  Parsing-Mechanismen.\\
		\noindent Die Realisierung einer Virtualisierungserkennung, welche ausschließlich auf der Existenzvalidierung bestimmter Dateien oder Verzeichnisse basiert, muss aufgrund der Heterogenität disparater Implementierungen von Betriebssystemen und Hypervisor als ambivalent bewertet werden. Während sich die Realisierung dieses Ansatzes bei bekannten Verzeichnisstrukturen vergleichsweise einfach gestaltet, ist die Wahrscheinlichkeit defizitärer Detektionsresultate hoch. So könnte beispielsweise ein physisches Host-System, welches lediglich eine der entsprechenden Virtualisierungslösungen installiert hat, aufgrund der Existenz zahlreicher Dateien mit korrespondierenden Substring-Anteilen fälschlicherweise als virtualisiert identifiziert werden. Die punktuelle Verifikation der Präsenz bestimmter Dateien kann dennoch als supportives Element im Kontext der Gesamtdetektion eingesetzt werden, weshalb im Rahmen dieser Arbeit eine grobgranulare Analyse der Dateiverteilung in virtualisierten Systemumgebungen realisiert. In Unix-Umgebungen werden die als potentielle Identifikatoren identifizierten Dateien im Schwerpunkt innerhalb der Verzeichnisse /sys/firmware und /proc abgelegt; insbesondere die Installation der jeweiligen Gasterweiterungen induziert hierbei oftmals ein inkrementiertes Detektionspotential, sodass beispielsweise die reine Existenz der Verzeichnisse /var/lib/vmware und /etc/vmware-tools einen relevanten Beitrag zur Hypervisor-Erkennung leisten kann. Die Verteilung von Dateien und Verzeichnissen mit potentiell kompromittierenden Namensattributen ist in Windows-Systemen aufgrund des im weiteren Verlauf dediziert analysierten \textit{Registry}-Elements massiv limitiert.
		Die unten dargestellte Tabelle \ref{tab:messungen_dateisystem} visualisiert exemplarisch die absolute Anzahl von Dateien, welche auf Basis ihrer Namensattribute als potentielle Indikatoren zur Detektion virtualisierter Umgebungen identifiziert werden konnten. Die Erfassung der Daten	wurde dabei auf Basis der nativ integrierten Suchmechanismen \textit{find} \mbox{(Unix-Umgebungen) und \textit{dir /s} (in der Windows-Umgebung) realisiert.}

		\renewcommand\arraystretch{1.2}% (MyValue=1.0 is for standard spacing)
		\begin{table}[h]
			\caption[Übersicht der Resultate präfixbasierter Dateisystem-Analysen]
			% ^Alternativer Text für das Abb.verzeichnis
			{Übersicht der Resultate präfixbasierter Dateisystem-Analysen}
			\label{tab:messungen_dateisystem}
			\vspace{\baselineskip}
			
			\noindent\begin{tabular} {|m{4,28cm}|m{4,2cm}|m{5cm}|} %Summe 13,75
				
				\hline
				
				\textbf{} & \textbf{Oracle VirtualBox} & \textbf{VMware Workstation Pro}\\
				\textbf{} & (Substring: *vbox*) & (Substring *vmware*|*vmx*)\\ \hline
				
				\textbf{Windows 10 Pro} & 0 & 37 (28+9) \\\hline
				
				\textbf{Ubuntu 16.04.3 LTS} & 44 & 530 (174+346) \\\hline
				
				\textbf{Ubuntu Server 16.04.3} & 148 & 99 (19+80) \\\hline
			\end{tabular}
		\end{table}
		\vspace{\baselineskip}
		\vspace{\baselineskip}
		\noindent Einen weiteren, fundamentalen Bestandteil von Betriebssystem-Implementierungen stellt die Koordination systeminterner Abläufe in Form von \textit{Prozessen} dar. Ein Prozess repräsentiert hierbei die konkrete Instanziierung eines Programms zu dessen Ausführung innerhalb der Systemumgebung, wobei oftmals zusätzlich Verwaltungsinformationen zur Herstellung der Interoperabilität mit konkurrierenden Prozess-Instanzen generiert werden. Analog zu statischen Dateiobjekten können auch die dynamischen Prozessinkarnationen zur Detektion einer virtualisierten Systemumgebung genutzt werden. 
		Insbesondere die Nutzung integrierter Komfort-Funktionen wie dem Datenaustausch zwischen VM und Host-System, welche meist durch die Installation der zugehörigen Gasterweiterungen realisiert werden, induzieren im Regelfall dedizierte Hilfsprozesse auf dem Guest-System. Die Präsenz dieser Prozesse kann dann mit den Standard-Systemwerkzeugen detektiert und hinsichtlich Hypervisor-spezifischer Charakteristika der Prozessbenennung analysiert werden. So wird beispielsweise bei der Initiierung einer VirtualBox-Umgebung regulär der \textit{VBoxService}-Dienst unter /usr/sbin/VBoxService aktiviert, welcher die Identifikation des korrespondierenden Hypervisor-Elements ermöglicht. Analog hierzu sind in der VMware-Standardkonfiguration unter /usr/sbin/vmware* zahlreiche Prozesse aktiv, wobei in Abhängigkeit von der konkreten Systemparametrisierung meist bis zu fünf Prozessinstanzen simultan in Betrieb sind.\\
		\noindent Die manuelle Analyse der in diesem Kontext untersuchten Windows-Derivate liefert weitestgehend kongruente Resultate. Exemplarisch seien an dieser Stelle die Prozessinstanzen \textit{vmacthlp.exe} ('VMware Physical Disk Helper Service') und \textit{vmtoolsd.exe} (Daemon der Gasterweiterungen) referenziert, welche in der Standardinstallation des Betriebssystems unter Verwendung eines VMware-Hypervisors aktiv sind.
		In Ergänzung dazu können auch zahlreiche Dienste (im regulären Ruhebetrieb etwa zehn Instanzen) als aktiv identifiziert werden, welche beispielsweise zur Realisierung der Kommunikation zwischen Guest-System und koordinierender Workstation-Instanz sowie zur dynamischen Geräte-Emulation genutzt werden. Die Präsenz der korrespondierenden Virtualisierungslösung ist dabei aufgrund der verwendeten Namensattribute der Prozesse leicht detektierbar.\\
		
		\noindent Seit 1992 realisieren Implementierungen der Windows-Betriebssysteme die zentralisierte Verwaltung von System- und Drittanwendungen innerhalb einer dedizierten \textit{Windows-Registrierungsdatenbank} (häufig abkürzend als \textit{Registry} bezeichnet), welche als hierarchisch organisierte Konfigurationsdatenbank des gesamten Systems fungiert \cite{winregistry2}. %Quelle:http://www.wintotal.de/registry-unter-windows/
		Die hierin enthaltenen Elemente werden dabei nicht durch korrespondierende Dateiobjekte repräsentiert, sondern liegen lediglich in Form einer aggregierten Binärdatei vor. Hierdurch wird einer der Gründe repräsentiert, warum die rein dateibasierte Analyse von Windows-Systemen in den vorherigen Ausführungen auf die Generierung defizitärer Resultate limitiert war. Auf der übergeordneten Hierarchieebene differenziert sich die Registry strukturell in fünf \mbox{Subverzeichnisse} (auch als Wurzel-Schlüssel bezeichnet), welche jeweils die Konfigurationsparameter funktionaler Teilaspekte des Gesamtsystems repräsentieren. So werden beispielsweise  globale Systemeinstellungen in Form von Schlüssel-Wert-Paaren unterhalb des Schlüssels \textit{HKEY\_LOCAL\_MACHINE} abgelegt, während die nutzerspezifischen Konfigurationseinträge innerhalb einer dedizierten \mbox{Unterschlüssel-Struktur des Wurzel-Schlüssels \mbox{\textit{HKEY\_USERS} archiviert werden \cite{winregistry}.}}\\
		%Quelle: https://www.pcwelt.de/tipps/Grundwissen-zur-Windows-Registry-1218643.html
		In ihrer Funktion als zentrale Konfigurationsdatenbank integriert die Registry unter anderem die Identifikationsparameter von BIOS und mit dem System verbundenen Peripherie-Komponenten, um insbesondere die Kompatibilität von installierten Hardware- und Software-Elementen verifizieren zu können. Aus diesem Grund kann unter Verwendung einer Registry-Editierungshilfe die Substring-basierte Extraktion potentieller Virtualisierungs-Indikatoren realisiert werden, wobei die konkreten Namensattribute einzelner Schlüssel zwischen den individuellen Hypervisor-Implementierungen divergieren können. Einige universelle Elemente werden durch den folgenden Schlüssel repräsentiert:
		\begin{center}
			\textit{HKLM/HARDWARE/DESCRIPTION/System/SystemBiosVersion}
		\end{center}
				
		\noindent Das Resultat der Analyse dieser Schlüssel-Komponenten innerhalb einer exemplarischen Systemkonfiguration ist in Abbildung \ref{fig:registry} unten visualisiert; die Fähigkeit zur Registry-Editierung wird dabei durch die Windows-native Systemanwendung \textit{regedit} (\textit{Registry Edit}) offeriert. Aus den farblich eingefassten Einträgen lassen sich in dieser Konfiguration detaillierte Parameter der verwendeten Hypervisor-Implementierung extrahieren, deren Substring-basierte Untersuchung unter anderem durch Implementierungen der \textit{Nymain}-\makebox[\linewidth][s]{Malware zur Identifikation von potentiellen Analyseumgebungen eingesetzt wird \cite{mcafee0617}.}	
		%Quelle: https://www.mcafee.com/us/resources/reports/rp-quarterly-threats-jun-2017.pdf
	
		\begin{figure}[h] 
			\centering
			\includegraphics[width=0.85\textwidth]{Bilder/stats/registry_neu.png}
			\caption[Ausschnitt der Windows-Registry]{Exemplarischer Registry-Schlüssel zur VM-Identifikation}
			\label{fig:registry}
		\end{figure}
		
		\noindent Kongruent zur oben präsentierten Vorgehensweise können unter Verwendung beliebiger Registry-Editoren generische Parameter der aktuellen Systemkonfiguration akquiriert werden, wobei neben der Referenzierung BIOS-bezogener Datensätze zur Deduktion von Systemattributen primär Informationen über Hardware-Komponenten und die korrespondierenden Treiber extrahiert können. Werden beispielsweise unterhalb des Schlüssels 
		\begin{center}
			\textit{HKLM/SYSTEM/ControlSet001/Services/Disk/Enum}
		\end{center}
		unter Nutzung bekannter Namens-Präfixe wie \textit{vbox} oder \textit{vmware} virtuelle Festplatten-Instanzen identifiziert, kann meist unmittelbar der virtuelle Charakter der Systemumgebung gefolgert werden. Der hier präsentierte Detektionsvektor wurde beispielsweise von verschiedenen Derivaten des Banking-Trojaners \textit{Dridex} implementiert, um die Analyse innerhalb einer virtuellen Umgebung zu vermeiden \cite{mcafee0617}. 
		%quelle: 	https://www.mcafee.com/us/resources/reports/rp-quarterly-threats-jun-2017.pdf
		Aufgrund des umfangreichen Emulationsaufwandes sind entsprechende Virtualisierungsindizien in der Registry-Umgebung omnipräsent, sodass bereits in der Standard-Installation eines Windows-Systems etwa 500 Registry-interne VMware-Referenzen identifiziert werden konnten \cite{thwarting}. %Quelle: http://handlers.sans.org/tliston/ThwartingVMDetection_Liston_Skoudis.pdf
		Die Funktionalität zur Virtualisierungs-Detektion unter Instrumentalisierung der Registry ist weiterhin auch in Form eines adaptiven Metasploit-Moduls implementiert, dessen Analyseroutinen jederzeit dynamisch um neu identifizierte Schlüsselkomponenten \mbox{erweitert werden können \cite{msf}.}	\\
		%Quelle: https://github.com/rapid7/metasploit-framework/blob/master/scripts/meterpreter/checkvm.rb
		%	Explizites Metasploit-Tool 
		
		\noindent Die im Rahmen dieses Abschnittes präsentierten Ansätze zur Identifikation \mbox{virtualisierter} Systemumgebungen unter Verwendung elementarer Betriebssystem-Funktionalität liefern bei produktiven Systemen im Regelfall bereits hinreichend belastbare Resultate. Insbesondere die in Dateisystem und Prozesse integrierten Indikatoren für emulierte Hardware-Komponenten generieren verlässliche Ansatzpunkte zur Deduktion der eingesetzten Hypervisor-Implementierung.
		Eine exponierte Position nimmt bei der Analyse von Windows-Derivaten die zentrale Verwaltungsdatenbank Registry ein, welche den zu analysierenden Suchraum innerhalb des Zielsystems signifikant einschränkt. Hierbei ist jedoch stets der hohe Abstraktionsgrad der identifizierten Datensätze zu berücksichtigen; die Majorität der extrahierten Parameter wird direkt durch high-level Software generiert, \makebox[\linewidth][s]{deren Verhalten potentiell durch eine administrative Instanz manipuliert werden kann.}
			
	\section{VM-Artefakte in Hauptspeicherkomponenten}
	
		Die Identifikation von VM-Artefakten in der Hauptspeicherkomponente wird primär unter Ausnutzung einer architektonischen Anomalie realisiert, welche final in der Nutzung disparater Speicherbereiche zur Ablage globaler Systemvariablen resultiert. Um durch die konkurrierende Speichernutzung zwischen Host-System und virtuellen Systemen induzierte Konflikte im Bereich der verfügbaren Adresssegmente zu minimieren, müssen die Speicherbereiche der virtualisierten Systemumgebungen in einen isolierten, ursprünglich für Anwendungen reservierten Speicherbereich disloziert werden. Auf diese Weise wird final ein potentieller Detektionsvektor generiert, welcher auf der Interpretation der von einem untersuchten System verwendeten Hauptspeicherbereiche basiert.\\
		Als Referenzobjekte innerhalb der systemspezifischen Speicherkomposition fungieren repräsentative Systemvariablen, welche den Zugriff auf zentrale Hauptspeicher-Strukturen des nativen Betriebssystems realisieren. Eine dieser elementaren Systemstrukturen manifestiert sich im sogenannten \textit{Interrupt Descriptor Table} (IDT), welcher die Identifikatoren der kritischen System-Unterbrechungen (als \textit{Interrupts} bezeichnet) sowie die Hauptspeicheradressen der korrespondierenden Behandlungsroutinen in Form einer tabellarischen Übersicht bereitstellt. Die Speicherreferenz des IDTs selbst wird dabei durch ein dediziertes \textit{Interrupt Descriptor Table Register} (IDTR) gesichert, dessen Inhalt unter Verwendung der \textit{SIDT}-Prozessorinstruktion (Store Interrupt Descriptor Table Register) in ein generisches Prozessregister transferiert und dort isoliert analysiert werden kann. 
		Die emulierte Aktivität von virtualisierten Systeminstanzen auf dem Host-System resultiert dabei in der Notwendigkeit zur Generierung additiver, Guest-spezifischer IDT-Datenstrukturen, welche zur Vermeidung von Konflikten mit der regulären IDT-Struktur des Host-Systems außerhalb des Host-Speicherbereiches angelegt werden müssen. Innerhalb des Ausführungskontextes der physischen und virtuellen Betriebssystem-Instanzen wird die IDTR-Referenz entsprechend der systemspezifischen Speicherreservierungen kontinuierlich aktualisiert, sodass die Extraktion der jeweiligen Registerinhalte unter Verwendung der präsentierten SIDT-Instruktion realisierbar ist. Im Rahmen der \textit{redpill}-Publikationen analysierte die IT-Sicherheitsforscherin Joanna Rutkowska die speicherinhärenten Kompositionsspezifika, welche die Basis für die Interpretation der identifizierten Diskrepanzen innerhalb extrahierter IDTR-Referenzen darstellen. Hierbei konnte eine Limitierung der Speicherposition von IDT-Instanzen regulärer Host-Systeme auf numerisch kleinere Speicherbereiche identifiziert werden; die regulär verwendeten Adressintervalle wurden auf Basis extensiver Analysen innerhalb der untersuchten 32-Bit-Systeme auf die Umgebung der Adressen 0x80ffffff (Windows) und 0xc0ffffff (Linux) reduziert. Aufgrund der aus Prozessorperspektive anwendungsähnlichen Charakteristik einer Hypervisor-Implementierung wiesen die IDTR-Referenzen virtualisierter Systeminstanzen hingegen meist signifikant höhere Speicheradressen auf. So wurde beispielsweise der klassische IDT-Adressbereich für VMware-Hypervisor im Intervall 0xff000000-0xffffffff identifiziert, was aufgrund des markanten Abstandes final in der Verwendbarkeit des entwickelten Adresskriteriums als Virtualisierungs-Indikator resultiert. Eine kritische Evaluation der generierten Ergebnisse ist hierbei jedoch insbesondere im Kontext von Multiprozessor-Systemen obligatorisch, da individuelle Prozessorinstanzen jeweils über eine dedizierte Inkarnation des IDT verfügen; aufgrund dieser Tatsache ist zur Virtualisierungs-Detektion zusätzlich die Analyse reziproker Interdependenzen zwischen \mbox{prozessorspezifischen IDT-Strukturen zu realisieren \cite{johanna}.}	\\
		%Quelle: https://web.archive.org/web/20070911024318/http://invisiblethings.org/papers/redpill.html
		\noindent Die verwendete Methodik erweist sich aufgrund der weitestgehenden Unabhängigkeit von konkret verwendeten Betriebssystem- und Hypervisor-Implementierungen als beinahe universell einsetzbar, weshalb der konzeptionelle Ansatz sukzessive auch auf alternative Speicherstrukturen projiziert wurde. Klassisch können hierzu insbesondere die Datenstrukturen \textit{Global Descriptor Table} und \textit{Local Descriptor Table} genutzt werden, innerhalb welcher Einträge der Deskriptoren von Hauptspeichersegmenten zur speicherinternen Koordination des systemweiten Multitasking-Betriebs aggregiert werden. Analog zum Vorgehen im Kontext des IDT-Elements wird unter Verwendung einer dedizierten Prozessorinstruktion der Inhalt des korrespondierenden Referenzregisters extrahiert und analysiert, um die aktuell geladenen Speicherstrukturen als einer virtualisierten Systeminstanz zugehörig zu identifizieren. Die konkret im Rahmen der finalen Interpretation verwendeten Speicheradressdaten wurden durch den Sicherheitsanalysten Tobias Klein identifiziert, dessen prototypische Implementierung potentieller Detektionsmechanismen in den Anwendungen \textit{Scoopy Doo} und \textit{Jerry} (aktualisierte Variante: ScoopyNG) als zentrales Referenzelement innerhalb dieses  Forschungskontextes dient \cite{scoopy}.\\ %Quelle: http://www.trapkit.de/tools/scoopyng/index.html
		Ein konzeptionell modernisierter Detektionsansatz, welcher insbesondere die Interferenzen durch heute ubiquitär verwendete Multiprozessor-Systeme minimiert, wird unter Verwendung des prozessspezifischen \textit{Task State Segment} (TSS) realisiert. Diese Datenstrukturen offerieren dedizierte Speichersegmente zur Administration des Prozesszustandes sowie zur Koordination der korrespondierenden Registerkontexte und I/O-Transportprozesse der jeweiligen Prozessinstanzen. Auch hier können die von virtualisierten Systemen verwendeten Adressbereiche von nativen Speichereinträgen des Host-Systems differenziert werden, wodurch die Detektion der Präsenz von Hypervisor-Implementierungen möglich wird. Die isolierte Realisierung dieser Methode ist jedoch im Rahmen einiger Linux-Derivate als kritisch zu bewerten, da diese aus Gründen der Abwärtskompatibilität auf die prozessspezifische Implementierung der TSS-Datenstrukturen verzichten und den Geltungsbereich der Speichersegmente damit auf die jeweilige Prozessor-Instanz erweitern \cite{s21sec}.
		%Quelle: http://charette.no-ip.com:81/programming/2009-12-30_Virtualization/www.s21sec.com_vmware-eng.pdf
		
		\noindent Um final die durch Architektur- oder Instruktionsspezifika induzierten Interferenzeffekte zu marginalisieren, kann final die Implementierung exhaustiver oder partieller Analyseansätze des gesamten Hauptspeicherbereichs realisiert werden. Hierbei soll nicht die Existenz repräsentativer Datenstrukturen verifiziert, sondern die Präsenz kompromittierender Substring-Anteile innerhalb beliebiger Adressintervalle des Hauptspeichers detektiert werden. Im Rahmen dieser Arbeit wurde unter Verwendung der in Abschnitt \ref{sec:konzept} präsentierten Referenzsysteme eine exemplarische Realisierung des exhaustiven Analyseprozesses eingesetzt, dessen Resultate in der untenstehenden Tabelle \ref{tab:messungen} visualisiert sind. Erfasst wurde hierbei die absolute Anzahl von identifizierten Referenzen eines spezifizierten Substring-Elements, \mbox{welches die jeweiligen Hypervisor-Implementierungen eindeutig repräsentiert.}
			%Analysen:
		%Methodik erläutern!
		% VBOX mit installierten Guest-ADdiotions RAM-Dump WIndows10 knapp 200 (194) Referenzen zu Substring *vbox*, Ubuntu 3824, Ubuntu Server 2861
	%			VMWare mit installierten VMWare-Tools Windows10 1700 (1658) Referenzen zu "vmware", Ubuntu XXX, Ubuntu Server
				
			\renewcommand\arraystretch{1.095}% (MyValue=1.0 is for standard spacing)
			
			\begin{table}[h]
				\caption[Übersicht der Resultate Substring-basierter RAM-Analysen]
				% ^Alternativer Text für das Abb.verzeichnis
				{Übersicht der Resultate Substring-basierter RAM-Analysen}
				\label{tab:messungen}
				\vspace{\baselineskip}
				
				\noindent\begin{tabular} {|m{4,28cm}|m{4cm}|m{5,2cm}|} %Summe 13,75
					
					\hline
					
				\textbf{} & \textbf{Oracle VirtualBox} & \textbf{VMware Workstation Pro}\\
				\textbf{} & (Substring: *vbox*) & (Substring *vmware*)\\ \hline
				
				\textbf{Windows 10 Pro} & 194 & 1658 \\\hline
				
				\textbf{Ubuntu 16.04.3 LTS} & 3824 & 2048 \\\hline
				
				\textbf{Ubuntu Server 16.04.3} & 2861 & 213 \\\hline
			\end{tabular}
		\end{table}
		
		\noindent Aus dem vorliegenden Datensatz lässt sich ein stark systemspezifisches Integrationsverhalten der individuellen Hypervisor-Implementierungen in den regulären Systembetrieb deduzieren. Dieses Resultat kann primär durch die disparate Realisierung interner Optimierungsmechanismen begründet werden, welche beispielsweise im Kontext der Per- \mbox{formance-Maximierung} dediziert auf das vorliegende \mbox{System angepasst werden müssen.} \\
		
		\noindent Die Instrumentalisierung manueller, Substring-basierter Arbeitsspeicheranalysen ist im übergeordneten Kontext der Virtualisierungs-Detektion jedoch grundsätzlich als defizitär zu bewerten. Sowohl exhaustive als auch partielle Analysen größerer Hauptspeicherbereiche induzieren bei der ubiquitären Verfügbarkeit von Multi-Gigabyte-Speicherkomponenten suboptimale Performance-Kennzahlen. Weiterhin wird durch den Analyseprozess hoher Aufwand auf dem ausführenden Zielsystem generiert, was im direkten Widerspruch zum Verdecktheits-Anspruch der im Rahmen dieser Seminararbeit untersuchten Malware-Implementierungen steht. Kritisch ist hierbei zusätzlich die potentielle Detektion von Installations-Fragmenten bekannter Hypervisor-Implementierung auf Host-Systemen. Aufgrund der kompromittierenden Namensattribute würden diese als Indikatoren einer virtuellen Systemumgebung interpretiert, was final in der Generierung fehlerhafter Analyseergebnisse resultiert. Die Detektion repräsentativer Datenstrukturen innerhalb der Arbeitsspeicher-Umgebung lässt sich hingegen meist unter Verwendung singulärer CPU-Instruktionen realisieren. Durch den kombinierten Einsatz der konkreten Analyseansätze können die gewonnen Resultate dabei trotz individueller Defizite auch im Kontext heterogener Architektur- und Instruktionskonfigurationen weitestgehend stabilisiert werden.
	
	\section{VM-Artefakte in virtualisierten Hardware-Komponenten}\label{sec:komponenten}
	
		Ein kritisches Element bei der Implementierung von Hypervisor-Systemen stellt die performante Emulation der Interaktion zwischen Peripherie-Komponenten und virtualisierten Hardware-Schnittstellen dar. Diese wird häufig unter Verwendung Hypervisor-interner Pseudoregister realisiert, welche die entsprechende Treiber-Funktionalität simulieren \cite{s21sec}. 
		%Qeulle: http://charette.no-ip.com:81/programming/2009-12-30_Virtualization/www.s21sec.com_vmware-eng.pdf (oben schon)
		Die virtuellen Hardware-Komponenten können dabei im Regelfall anhand eindeutiger Indikatoren identifiziert werden, wobei neben kompromittierenden Namensattributen primär standardisierte Konfigurationsparameter zur Detektion genutzt werden. Diese Problematik lässt sich exemplarisch am Beispiel der Adressdaten-Vergabe  virtueller Netzwerkkarten visualisieren. Die Charakteristika einer Netzwerkumgebung werden unter Verwendung des \textit{Open Systems Interconnection Model} (kurz: OSI-Modell) auf Basis der Abstraktion von physischen Übertragungsparametern in sieben Schichten differenziert, wobei die erste Schicht zur Spezifikation physikalischer Attribute der konkreten Übertragungsmedien dient \cite{elektroarchiv}.
		% Quelle: https://web.archive.org/web/20101225235229/http://www.elektronik-kompendium.de/sites/kom/0301201.htm 
		Auf der Ebene des darauf aufbauenden \textit{Data Link Layer} fungieren global eindeutige, 48 Bit umfassende MAC-Adressen (\textit{Media Access Control}) als identifizierendes Element der Netzwerkadapter einer individuellen Systeminstanz. Die Garantie der Eindeutigkeit innerhalb des globalen Kommunikationskontextes basiert auf der zentralisierten Administration der Adressvergabe, welche durch das \textit{Institute of Electrical and Electronics Engineers} reguliert wird \cite{mac}. %Quelle: http://www.itwissen.info/MAC-Adresse-MAC-address.html
		Hersteller von Hard- und Software können dabei dedizierte Adressbereiche zur exklusiven Nutzung reservieren, um beispielsweise Produkte mit Adressdaten innerhalb des entsprechenden Intervalles vertreiben zu können. Auch im Kontext virtualisierter Netzwerkadapter ist eine kollisionsfreie Vergabe der MAC-Identifikatoren obligatorisch, um Interferenzen in der Kommunikation zwischen virtualisierten und physischen Systemen ausschließen zu können. Aus diesem Grund wurde ein Teil der global validen MAC-Adressdaten durch Hersteller von Virtualisierungslösungen reserviert, deren Präfixe nun bei der Detektion virtualisierter Systemumgebungen als verlässliche Indikatoren instrumentalisiert werden können. Innerhalb der im folgenden abgebildeten Tabelle \ref{tab:macs} ist ausschnittsweise eine Übersicht der entsprechenden Reservierungs-Präfixe für die bekanntesten Hypervisor-Implementierungen visualisiert.
		\renewcommand\arraystretch{1.1	}% (MyValue=1.0 is for standard spacing)
		% Quelle: https://www.techrepublic.com/blog/data-center/mac-address-scorecard-for-common-virtual-machine-platforms/
		\begin{table}[h]
			\caption[Reservierte MAC-Präfixe bekannter Virtualisierungslösungen]
			% ^Alternativer Text für das Abb.verzeichnis
			{Reservierte MAC-Präfixe bekannter Virtualisierungslösungen \cite{maclist}}
			\label{tab:macs}
			\vspace{\baselineskip}
			
			\noindent\begin{tabular} {|m{6cm}|m{7,75cm}|} %Summe 13,75
				
				\hline
				
				\textbf{Hersteller/Produkt} & \textbf{Reservierter MAC-Präfix}\\ \hline
				
				VMware ESXi, Workstation, Player & 00:50:56:*, 00:0C:29:*, 00:05:69:* \\\hline
				Oracle VirtualBox & 08:00:27:* \\\hline
				Microsoft Hyper-V & 00:03:FF:* \\\hline
				Parallells Desktop, Server, Virtuozzo & 00:1C:42:* \\\hline
				Citrix XenDesktop, XenServer & 00:16:3E:* \\\hline
				
			\end{tabular}
		\end{table}
		
		\noindent Zur systeminternen Identifikation der MAC-Adressdaten von installierten Netzwerkkomponenten werden durch alle gängigen Betriebssystem-Implementierungen zahlreiche, nativ integrierte Mechanismen offeriert. Meist kann diese Information bereits aus den im Vorfeld präsentierten Datensätzen oder den korrespondierenden Registry-Einträgen extrahiert werden. Grundsätzlich ist jedoch insbesondere im Virtualisierungs-Kontext die Manipulation von MAC-Adressdaten durch Vortäuschen arbiträrer Adressinformationen technisch vergleichsweise einfach realisierbar, weshalb die Resultate dieses Detektions- vektors stets durch Kombination mit alternativen Methoden validiert werden sollten. \\ 
		% Quelle: https://www.symantec.com/connect/blogs/malware-authors-using-new-techniques-evade-automated-threat-analysis-systems
		\noindent Wie bereits im vorhergehenden Abschnitt \ref{sec:filesystem} referenziert, offerieren in Unix-basierten Systemumgebungen insbesondere die Parameter der virtualisierten Hardware-Komponenten umfangreiches Potential zur Identifikation der eingesetzten Hypervisor-Realisierungen. Aufgrund des dateifokussierten Architekturkonzeptes reduziert sich die Umsetzung der entsprechenden Methoden im Schwerpunkt auf die manuelle Analyse singulärer Dateiobjekte und Instruktionen.
		Zur Vermeidung von Redundanzen und Inkonsistenzen wird die Evaluation potentieller Detektionsverfahren innerhalb des folgenden Abschnittes dabei auf die dedizierte Analyse nicht-nativer Peripheriekomponenten konzentriert, deren Betrachtung im Rahmen der vorherigen Abschnitte nur sekundär priorisiert wurde.\\
		\noindent In diesem Kontext können vor allem die Liste der aktiven Speicherkomponenten unter /dev/disk und virtualisierte Gerätetreiber effektiv zur Realisierung der Detektionsmaßnahmen instrumentalisiert werden. So visualisiert beispielsweise die folgende Instruktion
		\begin{center}
			ls -1 /dev/disk/by-id/
		\end{center}
		alle erfolgreich initialisierten Speicherkomponenten der aktuellen Systemumgebung. Zur Vermeidung von Interferenzen mit der Partitionskonfiguration des Host-Systems simulieren Virtualisierungslösungen die Hintergrundspeicher-Komponenten in der Regel unter Referenzierung eines dedizierten Dateiobjekts, dessen Inhalt durch die Hypervisor-Instanz dynamisch interpretiert wird. Die Majorität der Virtualisierungs-Umgebungen verwendet hierbei jedoch proprietäre und individuell implementierte Konzepte, welche anhand der verwendeten Namensattribute häufig als virtuelle Instanzen identifiziert werden können.
		Eine alternative Variante zur Instrumentalisierung des kongruenten Identifikationsvektors wird durch die bereits in Abschnitt \ref{sec:filesystem} referenzierte \textit{lshw}-Instruktion repräsentiert. Hierbei liefert die manuelle Filterung der erkannten Peripherie-Komponenten auf entsprechende \textit{virtual}-Präfixe im Regelfall die entsprechenden Treiber- oder Herstellerbezeichnungen. Insbesondere die emulierten Maus- und Tastatur-Instanzen generieren hierbei belastbare  Informationen, da diese im Simultanbetrieb eine dynamische Differenzierung zwischen Guest- und Host-System realisieren müssen. Dies erfolgt meist durch Implementierung eines koordinierenden Treibermoduls mit oftmals kompromittierenden Bezeichnungen, deren Extraktion beispielsweise unter Verwendung der generischen Instruktion
		\begin{center}
			lshw -businfo | grep usb
		\end{center}
		realisiert werden kann. Eine zusätzliche Inkrementierung des verfügbaren Detailgrades von Informationen über virtualisierte Systemschnittstellen kann durch das \mbox{\textit{hwinfo}}-Werkzeug generiert werden, dessen Installationsarchiv im Regelfall innerhalb der Standard-Paketquellen zur Verfügung gestellt wird. Von besonderer Relevanz sind in diesem Kontext die dedizierten USB-Komponentenauflistungen, deren Analyse unter Instanziierung des \textit{usb}-Parameters induziert wir. Im Rahmen einer exemplarischen Durchführung unter Einsatz des Ubuntu-Referenzsystems konnten innerhalb einer VMware-Umgebung etwa 300 Referenzen mit kompromittierenden Namensattributen detektiert werden. \\
		Ergänzt werden die in diesem Kapitel präsentierten Analyseansätze auf Basis emulierter Peripherie-Komponenten durch Interpretation des untenstehenden Dateisystem-Objektes:
		\begin{center}
			cat /proc/ide/hd*/model 
		\end{center}
		Der lesende Zugriff auf dieses Element ermöglicht die Visualisierung von zentralen Geräteparametern der externen Laufwerke, wobei insbesondere emulierte CD/DVD-Laufwerke umfangreiche Informationen über die Systemkonfiguration emittieren. Da die Interaktion mit potentiell präsenten, physischen Laufwerken aufgrund der Verwaltungskomplexität durch einen Hypervisor nicht transparent zur Verfügung gestellt werden kann, wird die erforderliche Schnittstelle im Regelfall durch eine virtualisierte Vermittlungsinstanz repräsentiert. Die Präfix- oder Substring-basierte Interpretation der entsprechenden Namensattribute ermöglicht dabei oftmals die Deduktion grundlegender VM-Parameter. Eine feingranulare Übersicht von methodisch kongruenten Analyseansätzen unter Verwendung ähnlicher Konzepte ist unter \cite{allunix} explizit dargestellt und erläutert. %Quelle: https://upwork.link/hostings/1325/%Quelle: https://upwork.link/hostings/1325/
		\\
		\noindent Analog zur dedizierten Analyse von virtuellen Systemkomponenten kann auch die Examination der koordinierenden BUS-Kommunikationsinstanzen zur Identifikation virtualisierter Systemumgebungen instrumentalisiert werden. Unter Verwendung der Instruktion
		\begin{center}
			cat /proc/scsi/scsi
		\end{center}			  
		können beispielsweise die über den emulierten SCSI-Bus (Small Computer System Interface) angeschlossenen Peripheriegeräte des Systems identifiziert werden, wobei  insbesondere die virtualisierten Geräte-Instanzen (beispielsweise emulierte Festplatten oder CD/DVD-Laufwerke) aufgrund ihrer Namensattribute als virtuell identifizierbar sind.
		Das SCSI-Subsystem eines Rechensystems offeriert den integrierten Komponenten standardisierte Protokolle und Schnittstellen zur Interaktion und Datenübertragung, ist dabei aufgrund der kontinuierlichen Expansion des SATA-Standards jedoch zunehmend auf den Einsatz in Hochleistungs-Serverkontext limitiert \cite{macknubbel}.\\ % Quelle: http://www.knubbelmac.de/hardware/scsi/
		\noindent Weitestgehend omnipräsent sind in aktuellen Systemkonfigurationen hingegen die generischen Bus-Schnittstellen des PCI-Standards (\textit{Peripheral Component Interconnect}), welche aufgrund der plattformunabhängigen Protokoll-Implementierung weitestgehend frei in allen Systemarchitekturen eingesetzt werden können. Aus funktionaler Perspektive realisiert der Standard die protokollarischen Grundlagen zur Herstellung der systeminhärenten Interoperabilität zwischen CPU und angeschlossenen Peripheriekomponenten, wobei unter Verwendung der \textit{lspci}-Instruktion (\textit{list pci}) eine Übersicht der aktiven Komponenten sowie korrespondierender Konfigurationsparameter generiert werden kann \cite{russia}. %Quelle: http://pinouts.ru/Slots/PCI_pinout.shtml. 
		Die Implementierungen aktueller Virtualisierungslösungen intensivieren hierbei kontinuierlich die konsistente Emulation real existierender Hardware-Komponenten, um die Authentizität der individuellen Virtualisierungsumgebungen zu maximieren; exemplarisch sei an dieser Stelle auf die ubiquitäre Verwendung der INTEL PRO/1000-Familie zur Virtualisierung von Netzwerkadaptern verwiesen \cite{lewan}. %quelle:https://www.lewan.com/blog/choosing-the-right-vmware-nic-should-you-replace-your-e1000-with-the-vmxnet3
		Vor diesem Hintergrund gestaltet sich die Extraktion von konkreten Virtualisierungs-Indizien mitunter als komplex. Die Besonderheiten der virtuellen Systemumgebung erfordern jedoch insbesondere bei Visualisierungskomponenten (Grafikkarte) und Peripherie-Schnittstellen (USB) stark spezialisierte Implementierungen, welche meist Identifikatoren des Herstellers der verwendeten Virtualisierungsumgebung beinhalten. Auf diese Weise kann die dedizierte Analyse der quantitativ limitierten \textit{lspci}-Ausgabe häufig dennoch einen signifikanten Beitrag zur Virtualisierungs-Detektion leisten.\\
			%- ls -1 /dev/disk/by-id/
			%  (Visualisiert die virtualisierten Speicherkomponenten, da Hersteller meist propietäre und inidivudell gekennzeichnete Derivate einsetzen unter fast allen bekannten Virtualisierungslösungen realisierbar)
			%- lshw, bereits bei DATEISYSTEMEN verwendet hier Filterung der erkannten Peripherie-Komponenten auf virtual-Präfixe in Treiber- oder Herstellerbezeichnung möglich. Insbesndere auch Maus und Tastatur gute Kandidaten, aufgrundDifferenzierung zwischen Guest- und Host-System meinst Implementierung zusätzlicher Treibermodule erforderlich (lshw -businfo | grep usb)
			%  Noch detailliertere Auflistung durch externes \textit{hwinfo}-Werkzeug, kann aus den Standard-Paketquellen installiert werden
			%- cat /proc/ide/hd*/model  
			%  (Geräteparameter externer Laufwerke, primär CD/DVD-Laufwerk. Kann durch Hypervizor nicht transparent zur Verfpgung gestllet werden, immer virtualisierte Vermittlungsinstanz präsent, daher präfixbasierte ANalyse sinnvoll) 
			%Übersicht Methodiken unter Verwendung dieses  konzeptionellen Ansatzes unter \textcolor{red}{[11]} %Quelle: https://upwork.link/hostings/1325/
			%- cat /proc/scsi/scsi 
			%  (Identifiziert über emulierten SCSI-Bus (Small Computer System Interface) angeschlossene Peripheriegeräte, bei virtualisierten Systemen hier häufig Emulation des CD/DVD-Laufwerks mit QEMU-Präfix als virtuell identifizierbar.)
			%- lspci 
			%  (Zeigt alle verbunden PCI-Geräte an; häufig real existierende Hardware-Komponenten emuliert, keine Ifnromatnen verfügbar. Besonderheiten der Virtualisierung  erfordern jedoch insbesondere bei Visualisierungskomponenten und Peripherie-Schnittstellen spezialisierte Implementierungen, welche meist Identifikatoren des Herstellers einer verwendeten Virtualisierungsumgebung beinhalten.) 
		\noindent Final können auch ausgewählte Attribute der integrierten CPU-Komponenten zur Detektion von Hypervisor-Implementierungen genutzt werden. So ermöglicht die Examination der Systemdatei \textit{/proc/cpuinfo} die Extraktion von aktiven Prozessor-Flags, welche als Steuersignale prozessorinterner Abläufe fungieren. In virtualisierten Systemumgebungen können hierbei im Regelfall die Flags \textit{vme} (Kurzform für \textit{Virtual Machine Environment}) und \textit{hypervisor} identifiziert werden, welche als Indikator für den auf Virtualisierung optimierten Prozessorbetrieb interpretiert werden können. Alternativ offeriert die in den Standard-Paketquellen verfügbare Analyseimplementierung \textit{cpuid} die Visualisierung detaillierter Prozessorattribute, welche die Konstitution des aktuellen Systemkontextes unter Verwendung des boolschen Parameters '\textit{hypervisor guest status}' (\textit{true} bei Betrieb virtueller Systeme) und dem repräsentativen Namensattribut \textit{hypervisor\_id} deduzieren.
		Eine Kombination der hierbei verwendeten Informationsfragmente wird innerhalb der \textit{system-detect-virt}-Anwendung verwendet, welche nativ in die aktualisierte Fassung des Unix-Initialisiungskontextes \textit{systemd} integriert ist. Auf Grundlage einer internen Datenbank kann unter Verwendung der generierten Resultate final eine Prognose über den \makebox[\linewidth][s]{potentiellen Hersteller der identifizierten Hypervisor-Implementierung formuliert \cite{systemd}.}\\ 
		\noindent In Windows-Umgebungen werden die hier präsentierten Informationsfragmente zentral in \makebox[\linewidth][s]{den entsprechenden Registry-Verzeichnissen (wie \textit{HKLM/HARDWARE}) aggregiert \cite{winregistry2}.}
	
%			- cat /proc/cpuinfo
%			  (Flags enthalten VME \textit{Virtual Machine Environment} und Hypervisor; detaillierte Prozessor-Informationen durch http://www.etallen.com/cpuid.html )
%			- systemd-detect-virt %Quelle: http://0pointer.de/blog/projects/detect-virt.html
%			  (nutzt intern BIOS-Informationen und CPU-ID Instruktion)
			  
	
			  
		\vspace{\baselineskip}	  
		\noindent Neben der statischen Examination repräsentativer Hardware-Attribute können auch Aspekte der dynamischen Verhaltensanalyse in die finale Detektionsentscheidung integriert werden. Insbesondere im Kontext kombinierter Malware-Analysen wird die reine Systemvirtualisierung meist um die Emulation einer produktiven Netzwerkumgebung ergänzt, welche beispielsweise zur Protokollierung des durch Botnetz-Instanzen initiierten \textit{Command-and-Control}-Netzwerkverkehrs (auch als C\&C-Traffic bezeichnet) eingesetzt werden kann. Um innerhalb der strikt isolierten Infrastruktur die vermeintliche Erreichbarkeit von koordinierenden C\&C-Serversysteme simulieren zu können, werden dabei sämtliche Dienstanfragen an externe Systeme universell durch scheinbar valide Antwortpakete quittiert. Exemplarisch seien an dieser Stelle die generische Beantwortung von \textit{Echo-Requests} des \textit{Internet Control Message Protocols} (ICMP), sogenannter \textit{Pings}, oder die erfolgreiche Namensauflösung invalider Domain-Identifikatoren durch das \textit{Domain Name System} (DNS) referenziert. Diese Mechanismen können durch die Malware-Derivate zur Detektion der Analyseumgebung instrumentalisiert werden, indem diese beispielsweise die Erreichbarkeit von Systemen mit nicht vergebenen Adressdaten verifizieren oder DNS-Namensauflösungen für aleatorisch generierte Domain-Einträge (deren Existenz oder zwischenzeitliche Reservierung hinreichend unwahrscheinlich ist) initiieren. Die entsprechende Reaktion der Systemumgebung mit scheinbar validen Antwortparametern wird hierbei als Indikator für die Präsenz einer virtualisierten Analyseumgebung interpretiert. \\
		Analog hierzu lassen sich auch physische Limitierungen von Peripheriekomponenten \mbox{einsetzen}, um das entsprechende Element als emuliert zu identifizieren. Generiert zum Beispiel das durch Hardware-Instruktionen mehrfach pro Sekunde induzierte Öffnen und Schließen des CD/DVD-Laufwerks keinerlei Fehlermeldungen auf Seiten des Host-Systems, kann dies als Hinweis auf dessen Virtualisierung gewertet werden. Ein weiteres, vergleichbares Kriterium wird durch die kontinuierliche Modifikation von aktiven Netzwerkkonfigurationen der Systemadapter repräsentiert, deren latenzfreie Realisierung ebenfalls als Indikator für die Präsenz virtualisierter Systemkomponenten fungieren kann. \\
		
		\noindent Die Relevanz des \mbox{peripheriebasierten} Analysevektors wird zusätzlich durch die Omnipräsenz automatisierter Installationsmechanismen in produktiven Netzwerkumgebungen inkrementiert, deren Nutzung oftmals in der Verwendung global kongruenter Default-Parameter einzelner Komponenten resultiert. Insbesondere im Kontext virtualisierter Systemumgebungen muss aufgrund der nativ integrierten Replikationsmechanismen (\textit{Cloning}) sowie vereinfachter Installationsszenarien (exemplarisch sei an dieser Stelle VMware-EasyInstall referenziert) häufig eine weitestgehende Homogenisierung der emulierten Hardware-Komponenten in Konfiguration, Komposition und Identifikatoren konstatiert werden. Dies ermöglicht in letzter Konsequenz die Generierung einer repräsentativen Signaturdatenbank, auf deren Basis die kombinierte Identifikation von Aspekten der Standardkonfiguration der \mbox{hier betrachteten VM-Installationen realisiert werden kann.}

		
	\section{VM-Artefakte in architekturspezifischen Prozessorinstruktionen}	
	
		% BESTE QUELLE EU WESThttps://www.codeproject.com/Articles/9823/Detect-if-your-program-is-running-inside-a-Virtual
		%http://resources.infosecinstitute.com/how-malware-detects-virtualized-environment-and-its-countermeasures-an-overview/#gref
		Die exponierte Position des Prozessorelements innerhalb einer Rechnerstruktur resultiert in der Notwendigkeit zur Hypervisor-seitigen Implementierung intensiver Optimierungsmechanismen, welche zur Minimierung der durch Virtualisierungseffekte induzierten Performanceverluste konzipiert wurden. Hierzu sind insbesondere die Kommunikationsmechanismen zwischen Hypervisor-Ebene und Prozessor-Hardware von Relevanz, deren Implementierung im Kontext virtualisierter Systemumgebungen potentielle Detektionsvektoren generiert. Aus diesem Grund wird im Rahmen des folgenden Abschnittes eine dedizierte Evaluation von konkreten Parametern der Prozessorumgebungen hinsichtlich ihrer Verwendbarkeit zur Identifikation von virtuellen Ausführungsumgebungen realisiert.
		
	 	\noindent Eine initiale Informationsgewinnung über zentrale Konfigurationsattribute des Prozessor-Elements kann dabei unter Verwendung der x86-/x86\_64-Instruktion \textit{CPUID} (\textit{CPU Identification}) durchgeführt werden. Diese nativ in den regulären Befehlssatz integrierte Instruktion wird durch explizite  Instanziierung des dedizierten CPUID-Befehls initiiert, wobei die Instruktion durch Einfügen eines CPUID-Abfragecodes in das EAX-Prozessorregister dynamisch parametrisiert werden kann. Aus funktioneller Perspektive wird hierbei die Extraktion von ausgewählten Attribute einer internen Prozessorsignatur aus spezialisierten Maschinenstatus-Registern realisiert, wobei die auf Basis der Parametrisierung generierten Rückgabewerte innerhalb der generischen Register EBX, ECX und EDX (jeweils 32 Bit Breite) abgelegt werden. Basierend auf der konkreten Komposition des Abfragecodes repräsentieren diese meist die Verfügbarkeit von Features in der verwendeten Prozesskonfiguration, welche in Form eines charakteristischen Bit-Strings visualisiert wird.
	 	Die Verwendung spezialisierter Abfragecodes erlaubt hingegen auch die gezielte Extraktion von Herstellerdaten, wobei im Kontext virtualisierter Systemumgebungen insbesondere das Namensattribut der \textit{hypervisor-id} von Relevanz ist. Wird im Rahmen der Instruktionsemulation die Präsenz einer koordinierenden Hypervisor-Instanz detektiert, kann unter Einsatz der drei generischen Prozessorregister EBX, ECX und EDX die intern gesicherte \textit{hypervisor-id} extrahiert und mithilfe der ASCII-Codierung in lesbare Informationsdaten transformiert werden. Als Resultat der verfügbaren Speicherbreite von 12 Byte (drei Zielregister mit jeweils 4 Byte Breite) sind die generierten Namensattribute konventionsgemäß auf eine Länge von 12 Zeichen festgelegt, wobei aufgrund der restriktiven Kapazitätslimitierungen auf die explizite Nullterminierung der einzelnen String-Attribute verzichtet wird. 
	 	Die Realisierung dieser Konventionen resultiert häufig in der Vergabe repetitiver Namensstrukturen, welche potentiell mit additiven Padding-Daten aufgefüllt werden müssen; primär sind dabei im Kontext virtueller Systemumgebungen die \textit{hypervisor-id}s 'VMwareVMware' (VMware), 'XenVMMXenVMM' (Xen-Systeme) und 'KVMKVMKVM\textbackslash x00\textbackslash x00\textbackslash x00' (VirtualBox) präsent, wobei die innerhalb der konsolenbasierten Ausgabe als Leerzeichen interpretierten \textbackslash x00-Nullbytes als arbiträre Padding-Daten fungieren \cite{lowlevel}. %Quelle: https://www.lowlevel.eu/wiki/CPUID
	  	Eine exemplarische Implementierung dieses konkreten Detektionsvektors findet sich beispielsweise im Quellcode des \textit{Necurs}-Trojaners, welcher nach Abschluss der Initialkompromittierung als Element weiterer Malware-Distribution fungiert. Die angestrebte Weiterverbreitung wurde dabei durch inhärente Botnetz-Strukturen realisiert, welche im Jahr 2016 etwa sechs Millionen kompromittierte Endgeräte umfasste \cite{mcafee0617}.
	  	% Quelle: https://www.mcafee.com/us/resources/reports/rp-quarterly-threats-jun-2017.pdf	 
	 	Zusätzlich kann die automatisierte Extraktion und visuell aufbereitete Präsentation der generierten Resultate dabei unter Verwendung der bereits in Abschnitt \ref{sec:komponenten} referenzierten \textit{cpuid}-Anwendung realisiert werden. Die Nutzung des \textit{-r}-Parameters ermöglicht weiterhin die Visualisierung des aktuellen Registerzustandes der Prozessorumgebung zum Zeitpunkt der Instruktionsdurchführung, wodurch auch eine manuelle Analyse der entsprechenden Datensätze ermöglicht wird.\\
		\noindent Ein alternativer Detektionsansatz wird durch die Instrumentalisierung der systeminhärenten Separation disjunkter Privilegierungsstufen repräsentiert. Die global verbreitete x86-Architektur offeriert in diesem Kontext ein Modell mit vier Domänen (aufgrund der oftmals konzentrischen Visualisierungsform auch als \textit{Ringe} bezeichnet), welche die sukzessive Restriktion von aktiven Prozessen der Domänen hinsichtlich der Verwendung des CPU-Befehlssatzes realisieren. Lediglich die Prozesse des innersten Rings (Ring 0) können hierbei den vollständigen CPU-Befehlssatz uneingeschränkt nutzen und direkte Hardware-Zugriffe durchführen; innerhalb dieser Domäne werden primär die internen Prozesse des Betriebssystem-Kernels implementiert, welche potentielle Hardware-Interaktionen der darauf aufbauenden Anwendungsschichten koordinieren. Die Interoperabilität zwischen den Domänen-Instanzen wird dabei durch sogenannte \textit{Gates} realisiert, welche als Schnittstelle für die Instanziierung von Kernel-Funktionalität fungieren. Unter Nutzung eines dedizierten \textit{Systemaufruf}-Interrupts wird dann der Kontextwechsel in die aufgerufene, in Ring 0 aktive Kernel-Routine induziert \cite{scienceismad}.
		In produktiven Systemumgebungen wird die Domänen-Separation jedoch häufig auf zwei Domänen limitiert, was mit der ausschließlichen Nutzung von Ring 0  für Kernel-Funktionalität und Ring 3 für Anwendungsprozesse identifiziert werden kann. Auf Basis dieser konzeptionellen Einschränkung werden aktive Prozesse und die korrespondierenden Berechtigungen meist in die Betriebsmodi Kernel-Modus (englisch: \textit{kernel mode}) und \mbox{Benutzer-Modus (englisch: \textit{user mode}) differenziert \cite{scienceismad}. }\\
		%Quelle: https://manybutfinite.com/post/cpu-rings-privilege-and-protection/ \\
		Im Kontext der Virtualisierungs-Detektion kann nun die Instanziierung privilegierter Instruktionen instrumentalisiert werden, um durch Analyse der korrespondierenden Interrupt-Routinen die Präsenz einer Hypervisor-Instanz zu deduzieren. Exemplarisch sei diese als \textit{Ring Exception Check} bezeichnete Technik in einer VMware-Umgebung unter Verwendung der privilegierten \textit{IN}- und \textit{OUT}-Instruktionen der x86-Architektur demonstriert, welche durch Interaktion mit spezifizierten Ein- und Ausgabeports der CPU die Kommunikation mit externen Peripherie-Komponenten realisieren. 
		Die Instanziierung dieser privilegierten Instruktionen wird auf einem physischen System aufgrund des defizitären Privilegierungsstatus durch den Interrupt \textit{EXCEPTION\_PRIV\_INSTRUCTION} quittiert, dessen Präsenz unter Verwendung interner Protokollmechanismen detektiert werden kann. Innerhalb einer virtualisierten VMware-Systemumgebung instrumentalisiert die verwendete Hypervisor-Instanz diese Instruktionen jedoch auch zur Einrichtung dedizierter Kommunikationskanäle zwischen Host- und Guest-Systemen, welche den Datenaustausch über virtuelle Pseudo-Ports simulieren. Da diese Funktionalität vollständig innerhalb des Benutzer-Modus implementiert werden kann und die Weiterleitung des Systemaufrufs durch die Hypervisor-Instanz blockiert wird, kann innerhalb von VMware-Systemen eine bestimmte Parametrisierung der \textit{IN}-Instruktion ohne Interrupt instanziiert werden. Initial wird hierzu das generische EAX-Register mit dem entsprechenden VMware-Parameter 0x564D5868 (nach ASCII-Dekodierung: 'VMXh') belegt, welcher die Intention zur dedizierten Interaktion mit der Hypervisor-Instanz signalisiert; die an den Hypervisor zu transferierenden Kommunikationsdaten werden dabei in Prozessor-Register ECX spezifiziert. Darauf aufbauen wird final die \textit{IN}-Instruktion instanziiert, welche lesenden Zugriff auf den physisch nicht vorhandenen, VMware-spezifischen Ein-/Ausgabeport 0x5658 (nach ASCII-Dekodierung: 'VX') realisieren soll \cite{vmdetectsource}. 
		%Quelle: https://www.codeproject.com/Articles/9823/Detect-if-your-program-is-running-inside-a-Virtual
		Induziert die Ausführung in der beschriebenen Systemkonfiguration das vorab präsentierte Interrupt-Element, kann von einer physischen Systemumgebung ausgegangen werden; liefert die Instruktion jedoch valide Nutzdaten (wie beispielsweise Versionsdaten der Hypervisor-Implementierung) ohne dedizierte Interrupt-Behandlung, kann basierend darauf die Präsenz einer virtualisierten Systemumgebung deduziert werden \cite{vmxh}.  
		%Quelle: https://www.aldeid.com/wiki/VMXh-Magic-Value
		In Ergänzung zur Instrumentalisierung der \textit{cpuid}-Instruktion wird auch dieser Detektionsansatz durch die \textit{Necurs}-Malware implementiert, um die Analyse interner Abläufe durch Analysten zu erschweren \cite{mcafee0617}.\\
		% Quelle: https://www.mcafee.com/us/resources/reports/rp-quarterly-threats-jun-2017.pdf
		\noindent Als ergänzender Indikator zur Virtualisierungs-Detektion wurde in der Vergangenheit bereits mehrfach die Evaluation von Ausführungszeiten verwendet. So implementiert beispielsweise die bekannte Ransomware \textit{Locky} eine dedizierte Test-Routine, welche unter Verwendung der x86-Instruktion \textit{RDSTC} (Read TimeStamp Counter) die Anzahl der verstrichenen Prozessorzyklen bei der Ausführung protokolliert \cite{mcafee0617}. 
		%Quelle: https://www.mcafee.com/us/resources/reports/rp-quarterly-threats-jun-2017.pdf
		Aufgrund des zusätzlichen Koordinationsaufwandes, welcher durch die Präsenz einer Hypervisor-Vermittlungsschicht induziert wird, resultiert die Ausführung einer Anwendung innerhalb virtualisierter Systemumgebungen meist in einer signifikanten Erhöhung der erforderlichen Taktzyklen. Diese Inkrementierung wird durch die Test-Funktionalität der \textit{Locky}-Implementierung detektiert; weichen die generierten Messwerte signifikant von einem statisch vordefiniertem Referenzwert ab, kann zur Vermeidung der Ausführung innerhalb potentieller Analyseumgebungen der Funktionsumfang dynamisch limitiert werden. Grundsätzlich eignet sich dieser Detektionsvektor jedoch höchstens in der Rolle als initiales Indikatorelement oder zur begleitenden Verifikation im Kontext anderer Methoden, da die auf diese Weise generierten Messwerte durch multiple Einflussfaktoren verfälscht werden können \cite{mcafee0617}.
		%Quelle: %Quelle: https://www.mcafee.com/us/resources/reports/rp-quarterly-threats-jun-2017.pdf
		
		
		%Ring Exception Check - IN Instruktion
		%durchführung privilegierter Instruktionen, um korrespondierende Interrupt-Routninen zu provozieren. Wird hierbei die Aktivität einer Vermittlungsinstanz, dem Hypervisor erkannt, kann mit ziemlcher Sicherheit Präsenz einer virtualisierten Systemumgebung deduziert werden. Hochkomplexes Feld, low-level, kaum gegenmaßnahmen realisierbar,
		%Communication Channel Check: Malware often checks any communication with the host. For this Malware executes the IN instruction. IN instruction is a privileged instruction and can only be run from Ring 0. However if it runs from Ring 3, then it will raise an exception. However when this instruction is triggered from malware within VM, no such exception if raised. Instead, the VM raises a connection with the host and if the magic number ?VMxh? is returned to the register EBX, malware is certain that it is currently running under a VM. 
		%Quelle 21.3.2 Generelles Problem bei der x86-Virtualisierung http://openbook.rheinwerk-verlag.de/ubuntu_1004/ubuntu_21_desktop_virtualisierung_003.htm#mj2b692add4c2a40ad647b4df409e492a2
		% besser: https://www.codeproject.com/Articles/9823/Detect-if-your-program-is-running-inside-a-Virtua
		
		%VMware-Spezifika:
			
		%	Figure 25: An old but still effective evasion technique is querying the input/output
		%	communication port used by VMware. Malware can query this port using the magic number
		%	?VMXh? with the x86 ?IN? instruction. During execution, the IN instruction is trapped by the
		%	virtual machine and emulated. The result returned from the instruction and stored in the
		%	register ebx is then compared to the magic number ?VMXh.? If the result matches, the malware
		%	is running on VMware and will terminate the process or attempt to crash the system. 
			
	
	\noindent Die direkte Interaktion der im Rahmen dieses Abschnittes präsentierten Methodiken mit den analysierten Hardware-Komponenten, deren Examination primär auf Basis der Instrumentalisierung nativer Hardware-Instruktionen realisiert werden kann, ermöglicht eine weitestgehende Universalität in der Auswahl potentieller Einsatzszenarien. Weiterhin können aufgrund der Direktheit in der Umsetzung Interferenzen durch intermediäre Betriebssystem-Funktionalität weitestgehend vermieden werden, sodass vergleichsweise belastbare Resultate bei minimalem Implementierungsaufwand generiert werden können. Dennoch sind auch in diesem Kontext manuelle Modifikationen der verwendeten Prozessorattribute oder der instrumentalisierten Rückgabe-Funktionalität grundsätzlich realisierbar, sodass ein eindeutiges Detektionsresultat kaum zu erzielen ist. Daher wird auch hier meist eine kombinierte Verwendung verschiedener Detektionsansätze eingesetzt. 
		
	%Finaler Fazit-Abschnitt
	\vspace{\baselineskip}
	\noindent Die Reaktion individueller Malware-Implementierungen auf die Detektion einer virtualisierten Systemumgebung wird im Regelfall in Abhängigkeit von der  Zielspezifikation der Malware-Administratoren realisiert. Zur Verschleierung interner Funktionalitätsparameter innerhalb des potentiellen Analysekontextes werden unter Berücksichtigung der kapazitären Restriktionen einer Malware-Implementierung verschiedene Gegenmaßnahmen realisiert, welche von der Terminierung elementarer Malware-Subprozesse über die Unterbindung jeglicher Verbindungsaufnahme mit instruierenden C\&C-Serverinstanzen bis hin zur aktiven Verschlüsselung der wesentlichen Quellcode-Anteile reichen können. Gemäß der Ausführungen zu Kapitelbeginn kann die kontinuierliche Expansion virtueller Systemumgebungen innerhalb des produktiven Betriebskontextes jedoch final in einer zunehmenden Spezialisierung von Malware-Derivaten auf die Kompromittierung virtueller Systeme resultieren, sodass zunehmend Methoden zur zusätzlichen, feingranularen Differenzierung zwischen regulären Virtualisierungslösungen und dedizierten Analyseumgebungen konzipiert und produktiv eingesetzt werden. 
	

%	Konsequenz der Detektion: \\
%			- Malware-Funktionalität terminiert\\
%			- Quellcode verschlüsselt\\
%			- Unterbindung Verbindungsaufnahme mit instruierenden C\&C-Serverinstanzen\\
			
	\noindent Basierend auf den Resultaten der vorhergehenden Abschnitte lässt sich die Erkenntnis deduzieren, dass eine exhaustive Detektionsprävention im Kontext virtualisierter Systemumgebungen aufgrund der hohen Diversität und Heterogenität potentieller Indikatoren kaum realisierbar ist. 
	Insbesondere die kombinierte Verwendung verschiedener Detektionstechniken ermöglicht dabei die Generierung belastbarer Resultate. Exemplarisch sei an dieser Stelle das Demonstrationstool \textit{Pafish} referenziert, welches kategorieübergreifend die Majorität der präsentierten Detektionsmethoden implementiert \cite{pafish}.	
	Um dennoch die innerhalb virtualisierter Analyseumgebungen generierten Resultate hinsichtlich ihrer Authentizität optimieren zu können, werden im Rahmen des folgenden Abschnittes zu den identifizierten Detektionsansätze grundlegende Gegenmaßnahmen konzipiert. Die Qualität der in statischer und dynamischer Malware-Analyse extrahierten Informationen bildet dabei die Grundlage für die Entwicklung von zukünftigen IT-Sicherheitssystemen.
	
	
